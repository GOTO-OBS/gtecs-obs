#!/usr/bin/env python
"""A script to approximate what the GOTO sentinel should be doing.

- Read in a LIGO GW skymap
- Split it up into tiles
- Insert those tiles into the GOTO database
"""

import argparse
import os
import time

import astropy.units as u

from gototile.grid import SkyGrid
from gototile.skymap import SkyMap

import obsdb as db


DB_USER = 'goto'
DB_PW = 'G0T0'
DB_NAME = 'GOTO GW alerts'

# Constant Pointing values
MPOINTING_SETTINGS = dict(start_rank=2,
                          minAlt=30,
                          minTime=360,
                          maxSunAlt=-18,
                          maxMoon='B',
                          minMoonSep=30,
                          ToO=0,
                          num_todo=5,
                          valid_time=1440,
                          wait_time=0)

# Constant ExposureSet values
EXP_SETTINGS = dict(expTime=120,
                    raoff=0.,
                    decoff=0.,
                    numexp=3,
                    typeFlag='SCIENCE',
                    filt='L',
                    binning=1,
                    utMask=None)


def add_to_database(pointings, event_time, event_name, survey_name, filename):
    """Add an event and its tiles to the GOTO database."""
    with db.open_session() as session:
        # Connect to the user, or create it if it doesn't exist
        try:
            userkey = db.get_userkey(session, DB_USER)
        except Exception:
            db.add_user(session, DB_USER, DB_PW, DB_NAME)
            userkey = db.get_userkey(session, DB_USER)

        # Create Event
        event = db.Event(name=event_name,
                         source='GW skymap',
                         ivo=str(event_time),  # no official IVON yet
                         skymap=filename)
        session.add(event)

        # Go through the pointings
        for pointing in pointings:
            # Get pointing infomation
            tile_name = str(pointing['tilename'])
            prob = float(pointing['prob'])

            # Find the matched Survey tile
            survey_tile = db.get_survey_tile_by_name(session, survey_name,
                                                     tile_name)

            # Create an EventTile and add to the database
            tile = db.EventTile(probability=prob)
            tile.event = event
            tile.surveyTile = survey_tile

            session.add(tile)

            # Create Mpointing and add to the database
            object_name = '{} {}'.format(event_name, tile_name)

            mpointing = db.Mpointing(userKey=userkey,
                                     objectName=object_name,
                                     **MPOINTING_SETTINGS)
            mpointing.surveyTile = survey_tile
            mpointing.event = event
            mpointing.eventTile = tile
            mpointing.exposure_sets.append(db.ExposureSet(**EXP_SETTINGS))

            session.add(mpointing)


def run(filename, hp_lim=0.001, n_lim=200):
    """Create the mpointings and add them to the database."""
    ra_fov = 5.5
    dec_fov = 2.6
    ra_overlap = 0.1
    dec_overlap = 0.1

    fov = {'ra': ra_fov * u.deg, 'dec': dec_fov * u.deg}
    overlap = {'ra': ra_overlap, 'dec': dec_overlap}

    # Create an all-sky grid with GOTO-tile
    grid = SkyGrid(fov, overlap)

    # open skymap and get event details
    print('Loading skymap...')
    skymap = SkyMap.from_fits(filename)
    event_time = skymap.date_det
    event_name = skymap.objid
    print('  loaded event {}'.format(event_name))

    # apply the skymap to the grid
    print('Getting skymap tile pointings')
    grid.apply_skymap(skymap)
    pointings = grid.get_table()
    pointings.sort('prob')
    pointings.reverse()
    print('  loaded {} pointings'.format(len(pointings)))

    # filter out low-priority pointings
    print('Filtering to tiles that contain more than {}%'.format(hp_lim * 100))
    hp_mask = pointings['prob'] > hp_lim
    selected_pointings = pointings[hp_mask]
    print('  found {} tiles that cover {:.1f}% of the skymap'.format(
        len(selected_pointings),
        sum(selected_pointings['prob']) / sum(pointings['prob']) * 100))

    # make sure we always add a minimum number of tiles
    if len(selected_pointings) < n_lim:
        print('Adding {} extra tiles to reach a minimum of {}'.format(
            n_lim - len(selected_pointings), n_lim))
        selected_pointings = pointings[:n_lim]
        print('  found {} tiles that cover {:.1f}% of the skymap'.format(
            len(selected_pointings),
            sum(selected_pointings['prob']) / sum(pointings['prob']) * 100))

    # add pointings to the database
    print('Adding {} tiles to the database...'.format(len(selected_pointings)))
    start = time.time()
    add_to_database(selected_pointings, event_time, event_name, grid.name, filename)
    print('  took {:.2f} secs'.format(time.time() - start))


if __name__ == '__main__':
    description = """Convert a GOTO-tile output file containing a list of tiles
                     and priorities into observation files for the G-TeCS
                     observation queue."""

    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('filename', help="skymap file")
    parser.add_argument('--priority', help="minimum priority", type=float, default=0.001)
    parser.add_argument('--number', help="minimum number", type=int, default=200)

    args = parser.parse_args()

    filename = os.path.realpath(args.filename)  # unpack relative paths

    run(filename, hp_lim=args.priority, n_lim=args.number)
