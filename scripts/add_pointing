#!/usr/bin/env python
"""A script to allow simple adding of pointings to the scheduler database."""

import getpass

import astropy.units as u
from astropy.coordinates import SkyCoord

import numpy as np

import obsdb as db


def parse_ra(ra_str):
    """Parse an RA string and return a float in decimal degrees, or ValueError.

    Valid formats:
        Decimal degrees
            e.g. "6" OR "212" OR "317.321"
        Hour Minute Second (space or colon seperated)
            e.g. "3 2 1" OR "10:0:0" OR "8 56 25.7"

    Will also check for limits (0 <= hours < 24 etc.)

    """
    ra_list = ra_str.replace(':', ' ').split()

    # option 1: decimal degrees
    if len(ra_list) == 1:
        try:
            ra_deg = float(ra_list[0])
        except Exception as error:
            raise ValueError('Invalid value for RA in degrees')
        if not 0 <= ra_deg < 360:
            raise ValueError('RA in degrees must be between 0 and 360')

    # option 2: hms notation
    elif len(ra_list) == 3:
        try:
            h = int(ra_list[0])
            m = int(ra_list[1])
            s = float(ra_list[2])
        except Exception as error:
            raise ValueError('Invalid input for RA in h m s')
        if not 0 <= h < 24:
            raise ValueError('RA hours must be between 0 and 24')
        if not 0 <= m < 60:
            raise ValueError('RA minutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('RA seconds must be between 0 and 60')
        ra_hrs = h + m / 60. + s / 3600.
        ra_deg = ra_hrs * 360. / 24.

    # they're the only options
    else:
        raise ValueError('Invalid input, use either deg or h m s')

    return ra_deg


def parse_dec(dec_str):
    """Parse an Dec string and return a float in decimal degrees, or ValueError.

    Valid formats:
        Decimal degrees
            e.g. "002" OR "194" OR "43.51"
        Degree Arcminute Arcsecond (space or colon seperated)
            e.g. "201 9 55" OR "+12:4:2.54" OR "-0 44 19"
        Sign Degree Arcminute Arcsecond (space or colon seperated)
            e.g. "+ 201 9 55" OR "+ 12:4:2.54" OR "- 0 44 19"

    Will also check for limits (0 <= minutes < 60 etc.)

    """
    dec_list = dec_str.replace(':', ' ').split()

    # option 1: decimal degrees
    if len(dec_list) == 1:
        try:
            dec_deg = float(dec_list[0])
        except Exception as error:
            raise ValueError('Invalid value for Dec in degrees')
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec in degrees must be between 90 and -90')

    # option 2: +dms notation (the old way)
    elif len(dec_list) == 4:
        if dec_list[0] not in ['+', '-']:
            raise ValueError('Sign should be "+" or "-"')
        sign = dec_list[0]
        try:
            d = int(dec_list[1])
            m = int(dec_list[2])
            s = float(dec_list[3])
        except Exception as error:
            raise ValueError('Invalid input for Dec in d m s')
        if not -90 <= d <= 90:
            raise ValueError('Dec degrees must be between 90 and -90')
        if not 0 <= m < 60:
            raise ValueError('Dec arcminutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('Dec arcseconds must be between 0 and 60')
        if sign == '+':
            dec_deg = d + m / 60. + s / 3600.
        else:
            dec_deg = -d - m / 60. - s / 3600.
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec must be between 90 and -90')

    # option 3: dms notation (need to extract sign, for -0)
    elif len(dec_list) == 3:
        if dec_list[0][0] == '-':
            sign = '-'
        else:
            sign = '+'
        try:
            d = int(dec_list[0])
            m = int(dec_list[1])
            s = float(dec_list[2])
        except Exception as error:
            raise ValueError('Invalid input for Dec in d m s')
        if not -90 <= d <= 90:
            raise ValueError('Dec degrees must be between 90 and -90')
        if not 0 <= m < 60:
            raise ValueError('Dec arcminutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('Dec arcseconds must be between 0 and 60')
        if sign == '+':
            dec_deg = d + m / 60. + s / 3600.
        else:  # NB d is negative
            dec_deg = d - m / 60. - s / 3600.
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec must be between 90 and -90')

    # they're the only options
    else:
        raise ValueError('Invalid input, use either deg or d m s')

    return dec_deg


def fill_mpointing(session, mpointing):
    """Fill out an mpointing frame with user input."""
    # On or off grid?
    ongrid = None
    while ongrid not in ['y', 'n', 'Y', 'N']:
        ongrid = input('Observe constrained to the grid? [y/n]: ')
    if ongrid in ['y', 'Y']:
        # Get the current grid
        db_grid = db.get_current_grid(session)

        # Create a SkyGrid from the database Grid
        grid = db_grid.get_skygrid()

        print('    Using grid {}'.format(db_grid.name))

        obstile = None
        while obstile not in ['1', '2']:
            obstile = input('Observe a specific tile [1] or find a tile from coordinates [2]?: ')
        if obstile == '1':
            tile_index = None
            while tile_index is None:
                tile_name = 'T' + input('Tile to observe: T')
                try:
                    tile_index = grid.tilenames.index(tile_name)
                except ValueError:
                    print('Could not find tile {} in grid {}'.format(tile_name, grid.name))
        else:
            target_ra = None
            target_dec = None
            while target_ra is None:
                ra_str = input('Target RA [h m s OR deg]: ')
                try:
                    target_ra = parse_ra(ra_str)
                except Exception:
                    pass
            while target_dec is None:
                dec_str = input('Target Dec [d m s OR deg]: ')
                try:
                    target_dec = parse_dec(dec_str)
                except Exception:
                    pass
            coord = SkyCoord(target_ra * u.deg, target_dec * u.deg)
            sep = np.array(coord.separation(grid.coords))
            tile_index = np.where(sep == (min(sep)))[0][0]
            tile_name = grid.tilenames[tile_index]

        # Find the matching GridTile
        query = session.query(db.GridTile)
        query = query.filter(db.GridTile.grid == db_grid,
                             db.GridTile.name == tile_name)
        db_grid_tile = query.one_or_none()
        if not db_grid_tile:
            raise ValueError('Cannot find tile in the database')

        print('    Using coords for {}: ra={:.4f}, dec={:.4f}'.format(db_grid_tile.name,
                                                                      db_grid_tile.ra,
                                                                      db_grid_tile.dec,
                                                                      ))
        mpointing['ra'] = db_grid_tile.ra
        mpointing['dec'] = db_grid_tile.dec
        mpointing['grid_tile'] = db_grid_tile

        # Object name
        default_name = db_grid.name + '_' + db_grid_tile.name + '_' + 'EXTRA'
        name = input('Enter Target name (blank for "{}"): '.format(default_name))
        if not name:
            name = default_name
        mpointing['object_name'] = name

    else:
        # We're off grid
        mpointing['grid_tile'] = None

        # Object name
        while mpointing['object_name'] is None:
            mpointing['object_name'] = input('Enter Target name: ')

        # Try coord lookup
        try:
            coord = SkyCoord.from_name(mpointing['object_name'])
        except Exception:
            coord = None
        if coord is not None:
            print('    Found catalogue object: ra={:.4f}, dec={:.4f}'.format(coord.ra.value,
                                                                             coord.dec.value))
            use_coords = None
            while use_coords not in ['y', 'n', 'Y', 'N']:
                use_coords = input('Use these coordinates? [y/n]: ')
            if use_coords in ['y', 'Y']:
                mpointing['ra'] = coord.ra.value
                mpointing['dec'] = coord.dec.value

        # Enter coords
        while mpointing['ra'] is None:
            ra_str = input('Target RA [h m s OR deg]: ')
            try:
                mpointing['ra'] = parse_ra(ra_str)
            except Exception:
                pass
        while mpointing['dec'] is None:
            dec_str = input('Target Dec [d m s OR deg]: ')
            try:
                mpointing['dec'] = parse_dec(dec_str)
            except Exception:
                pass

    # ToO & Rank
    too = None
    while too not in ['y', 'n', 'Y', 'N']:
        too = input('Is the target a ToO (can interupt)? [y/n]: ')
    if too in ['y', 'Y']:
        mpointing['too'] = 1
        rank_zero = 'None'
        while rank_zero not in ['y', 'n', 'Y', 'N']:
            rank_zero = input('Enter as Rank 0 (higher than GW targets - use with care)? [y/n]: ')
        if rank_zero in ['y', 'Y']:
            mpointing['start_rank'] = 0
        else:
            mpointing['start_rank'] = 506
    else:
        mpointing['too'] = 0
        rank_str = 'None'
        while rank_str.lower() not in ['low', 'medium', 'high', 'l', 'm', 'h']:
            rank_str = input('Enter rank [low/medium/high]: ')

        if rank_str.lower() in ['low', 'l']:
            mpointing['start_rank'] = 508
        elif rank_str.lower() in ['medium', 'm']:
            mpointing['start_rank'] = 507
        elif rank_str.lower() in ['high', 'h']:
            mpointing['start_rank'] = 506

    # Valid time & wait time
    daily = None
    while daily not in ['y', 'n', 'Y', 'N']:
        daily = input('Use default cadance (once a night)? [y/n]: ')
    if daily in ['y', 'Y']:
        mpointing['valid_time'] = -1
        mpointing['wait_time'] = 1000  # ensures once a night
    else:
        while mpointing['valid_time'] is None:
            valid_time = input('Time for the pointing to be valid for (minutes, -1=infinite): ')
            try:
                mpointing['valid_time'] = int(valid_time)
            except Exception:
                pass

        while mpointing['wait_time'] is None:
            wait_time = input('Time between visits (minutes, can be array, 0=no wait): ')
            try:
                mpointing['wait_time'] = [int(i) for i in wait_time.split(',')]
            except Exception:
                pass

    # Number to do
    while mpointing['num_todo'] is None:
        num_todo = input('Number of visits? (-1=infinite): ')
        try:
            mpointing['num_todo'] = int(num_todo)
        except Exception:
            pass

    # Constraings
    default_cons = None
    while default_cons not in ['y', 'n', 'Y', 'N']:
        string = 'Use default constraints (alt>30, sunalt<-15, moon<B, moonsep>30)? [y/n]: '
        default_cons = input(string)
    if default_cons in ['y', 'Y']:
        mpointing['min_alt'] = 30
        mpointing['max_sunalt'] = -15
        mpointing['max_moon'] = 'B'
        mpointing['min_moonsep'] = 30
    else:
        while mpointing['min_alt'] is None:
            invalue = input('Minimum target altitude (degrees): ')
            try:
                mpointing['min_alt'] = float(invalue)
            except Exception:
                pass

        while mpointing['max_sunalt'] is None:
            invalue = input('Maximum Sun altitude (degrees): ')
            try:
                mpointing['max_sunalt'] = float(invalue)
            except Exception:
                pass

        while mpointing['max_moon'] not in ['D', 'G', 'B']:
            invalue = input('Maximum Moon brightness [D/G/B]: ')
            try:
                mpointing['max_moon'] = invalue.upper()
            except Exception:
                pass

        while mpointing['min_moonsep'] is None:
            invalue = input('Minimum seperation from the Moon (degrees): ')
            try:
                mpointing['min_moonsep'] = float(invalue)
            except Exception:
                pass

    return mpointing


def fill_exposure_set(exposure_set):
    """Fill out an exposure set frame with user input."""
    # Number of exposures
    while exposure_set['num_exp'] is None:
        num_exp = input('Number of exposures: ')
        try:
            exposure_set['num_exp'] = int(num_exp)
        except Exception:
            pass

    # Exposure time
    while exposure_set['exptime'] is None:
        exptime = input('Exposure time: ')
        try:
            exposure_set['exptime'] = int(exptime)
        except Exception:
            pass

    # Filter
    while exposure_set['filt'] not in ['L', 'R', 'G', 'B']:
        filt = input('Filter [L/R/G/B]: ')
        try:
            exposure_set['filt'] = filt.upper()
        except Exception:
            pass

    return exposure_set


if __name__ == '__main__':

    default_mpointing = {'object_name': None,
                         'ra': None,
                         'dec': None,
                         'too': None,
                         'start_rank': None,
                         'num_todo': None,
                         'valid_time': None,
                         'wait_time': None,
                         'min_alt': None,
                         'max_sunalt': None,
                         'max_moon': None,
                         'min_moonsep': None,
                         # auto filled values
                         'min_time': None,
                         }

    exposure_sets = []

    default_exposure_set = {'num_exp': None,
                            'exptime': None,
                            'filt': None,
                            # default values:
                            'binning': 1,
                            'imgtype': 'SCIENCE',
                            }

    print("** Insert pointing into GOTO queue database **")
    with db.open_session() as session:
        # get the User, or make it if it doesn't exist
        try:
            user = db.get_user(session, username='goto')
        except ValueError:
            password = getpass.getpass(prompt="Creating default user - give password: ")
            user = db.User('goto', password, 'GOTO Survey')

        # Fill Mpointing infomation
        mpointing = default_mpointing.copy()
        mpointing = fill_mpointing(session, mpointing)

        # Fill Exposure Set infomation
        exposure_sets = []

        total_exptime = 0
        more_exposures = True
        while more_exposures is True:
            exposure_set = fill_exposure_set(default_exposure_set.copy())

            total_exptime += (exposure_set['exptime'] + 30) * exposure_set['num_exp']
            exposure_sets.append(exposure_set)

            add_more = None
            while add_more not in ['y', 'Y', 'n', 'N']:
                add_more = input('Add another exposure set? [y/n]: ')

            if add_more not in ['y', 'Y']:
                more_exposures = False

        mpointing['min_time'] = total_exptime

        mp = db.Mpointing(**mpointing, user=user)
        for exposure_set in exposure_sets:
            es = db.ExposureSet(**exposure_set)
            mp.exposure_sets.append(es)

        # Create the first Pointing (i.e. preempt the caretaker)
        p = mp.get_next_pointing()
        mp.pointings.append(p)

        print('~~ Final check ~~')
        print(mp)
        for es in mp.exposure_sets:
            print(es)

        confirm = None
        while confirm not in ['y', 'Y', 'n', 'N']:
            confirm = input('Add to the database? [y/n]: ')

        if confirm in ['y', 'Y']:
            db.insert_items(session, [mp])
            print('    Inserted into observation database')
        else:
            session.rollback()
            print('    Not inserted')
        print('Done')
