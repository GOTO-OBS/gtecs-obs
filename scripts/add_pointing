#!/usr/bin/env python
"""A script to allow simple adding of pointings to the scheduler database."""

import getpass

import astropy.units as u
from astropy.coordinates import SkyCoord

from gototile.grid import SkyGrid

import numpy as np

import obsdb as db


def parse_ra(ra_str):
    """Parse an RA string and return a float in decimal degrees, or ValueError.

    Valid formats:
        Decimal degrees
            e.g. "6" OR "212" OR "317.321"
        Hour Minute Second (space or colon seperated)
            e.g. "3 2 1" OR "10:0:0" OR "8 56 25.7"

    Will also check for limits (0 <= hours < 24 etc.)

    """
    ra_list = ra_str.replace(':', ' ').split()

    # option 1: decimal degrees
    if len(ra_list) == 1:
        try:
            ra_deg = float(ra_list[0])
        except Exception as error:
            raise ValueError('Invalid value for RA in degrees')
        if not 0 <= ra_deg < 360:
            raise ValueError('RA in degrees must be between 0 and 360')

    # option 2: hms notation
    elif len(ra_list) == 3:
        try:
            h = int(ra_list[0])
            m = int(ra_list[1])
            s = float(ra_list[2])
        except Exception as error:
            raise ValueError('Invalid input for RA in h m s')
        if not 0 <= h < 24:
            raise ValueError('RA hours must be between 0 and 24')
        if not 0 <= m < 60:
            raise ValueError('RA minutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('RA seconds must be between 0 and 60')
        ra_hrs = h + m / 60. + s / 3600.
        ra_deg = ra_hrs * 360. / 24.

    # they're the only options
    else:
        raise ValueError('Invalid input, use either deg or h m s')

    return ra_deg


def parse_dec(dec_str):
    """Parse an Dec string and return a float in decimal degrees, or ValueError.

    Valid formats:
        Decimal degrees
            e.g. "002" OR "194" OR "43.51"
        Degree Arcminute Arcsecond (space or colon seperated)
            e.g. "201 9 55" OR "+12:4:2.54" OR "-0 44 19"
        Sign Degree Arcminute Arcsecond (space or colon seperated)
            e.g. "+ 201 9 55" OR "+ 12:4:2.54" OR "- 0 44 19"

    Will also check for limits (0 <= minutes < 60 etc.)

    """
    dec_list = dec_str.replace(':', ' ').split()

    # option 1: decimal degrees
    if len(dec_list) == 1:
        try:
            dec_deg = float(dec_list[0])
        except Exception as error:
            raise ValueError('Invalid value for Dec in degrees')
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec in degrees must be between 90 and -90')

    # option 2: +dms notation (the old way)
    elif len(dec_list) == 4:
        if dec_list[0] not in ['+', '-']:
            raise ValueError('Sign should be "+" or "-"')
        sign = dec_list[0]
        try:
            d = int(dec_list[1])
            m = int(dec_list[2])
            s = float(dec_list[3])
        except Exception as error:
            raise ValueError('Invalid input for Dec in d m s')
        if not -90 <= d <= 90:
            raise ValueError('Dec degrees must be between 90 and -90')
        if not 0 <= m < 60:
            raise ValueError('Dec arcminutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('Dec arcseconds must be between 0 and 60')
        if sign == '+':
            dec_deg = d + m / 60. + s / 3600.
        else:
            dec_deg = -d - m / 60. - s / 3600.
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec must be between 90 and -90')

    # option 3: dms notation (need to extract sign, for -0)
    elif len(dec_list) == 3:
        if dec_list[0][0] == '-':
            sign = '-'
        else:
            sign = '+'
        try:
            d = int(dec_list[0])
            m = int(dec_list[1])
            s = float(dec_list[2])
        except Exception as error:
            raise ValueError('Invalid input for Dec in d m s')
        if not -90 <= d <= 90:
            raise ValueError('Dec degrees must be between 90 and -90')
        if not 0 <= m < 60:
            raise ValueError('Dec arcminutes must be between 0 and 60')
        if not 0 <= s < 60:
            raise ValueError('Dec arcseconds must be between 0 and 60')
        if sign == '+':
            dec_deg = d + m / 60. + s / 3600.
        else:  # NB d is negative
            dec_deg = d - m / 60. - s / 3600.
        if not -90 <= dec_deg <= 90:
            raise ValueError('Dec must be between 90 and -90')

    # they're the only options
    else:
        raise ValueError('Invalid input, use either deg or d m s')

    return dec_deg


def get_user_id(session, username):
    """Get the user_id for the given username, and create it if it doesn't already exist."""
    try:
        user_id = db.get_user_id(session, username)
        print('    Attributing pointings to user "{}"'.format(username))
    except Exception:
        # Create user if it doesn't exist
        print('    User "{}" not recognised, creating new user...'.format(username))
        description = input('Enter your full name: ')
        prompt = 'Give a password for {}: '.format(username)
        passwd = getpass.getpass(prompt=prompt)
        db.add_user(session, username, passwd, description)
        session.commit()
        user_id = db.get_user_id(session, username)

    return user_id


def fill_mpointing(mpointing):
    """Fill out an mpointing frame with user input."""
    # On or off grid?
    ongrid = None
    while ongrid not in ['y', 'n', 'Y', 'N']:
        ongrid = input('Observe constrained to the grid? [y/n]: ')
    if ongrid in ['y', 'Y']:
        # TODO: We should load the grid from the database
        fov = {'ra': 5.5 * u.deg, 'dec': 2.6 * u.deg}
        overlap = {'ra': 0.1, 'dec': 0.1}
        grid = SkyGrid(fov, overlap, kind='minverlap')

        db_surveys = session.query(db.Survey).filter(db.Survey.name == grid.name).all()
        if not db_surveys:
            db_survey = None
            raise ValueError('Cannot find grid in the database')
        else:
            db_survey = db_surveys[-1]
        print('    Using grid {}'.format(db_survey.name))

        obstile = None
        while obstile not in ['1', '2']:
            obstile = input('Observe a specific tile [1] or find a tile from coordinates [2]?: ')
        if obstile == '1':
            tile_index = None
            while tile_index is None:
                tile_name = 'T' + input('Tile to observe: T')
                try:
                    tile_index = grid.tilenames.index(tile_name)
                except ValueError:
                    print('Could not find tile {} in grid {}'.format(tile_name, grid.name))
        else:
            target_ra = None
            target_dec = None
            while target_ra is None:
                ra_str = input('Target RA [h m s OR deg]: ')
                try:
                    target_ra = parse_ra(ra_str)
                except Exception:
                    pass
            while target_dec is None:
                dec_str = input('Target Dec [d m s OR deg]: ')
                try:
                    target_dec = parse_dec(dec_str)
                except Exception:
                    pass
            coord = SkyCoord(target_ra * u.deg, target_dec * u.deg)
            sep = np.array(coord.separation(grid.coords))
            tile_index = np.where(sep == (min(sep)))[0][0]
            tile_name = grid.tilenames[tile_index]

        # Find the matching SurveyTile
        query = session.query(db.SurveyTile)
        query = query.filter(db.SurveyTile.survey == db_survey,
                             db.SurveyTile.name == tile_name)
        db_tile = query.one_or_none()
        if not db_tile:
            raise ValueError('Cannot find tile in the database')

        print('    Using coords for {}: ra={:.4f}, dec={:.4f}'.format(db_tile.name,
                                                                      db_tile.ra,
                                                                      db_tile.dec,
                                                                      ))
        mpointing['objectName'] = db_survey.name + '_' + db_tile.name + '_' + 'EXTRA'
        mpointing['ra'] = db_tile.ra
        mpointing['dec'] = db_tile.dec
        mpointing['survey_id'] = db_survey.db_id
        mpointing['survey_tile_id'] = db_tile.db_id

    else:
        # We're off grid
        mpointing['survey_id'] = None
        mpointing['survey_tile_id'] = None

        # Object name
        while mpointing['objectName'] is None:
            mpointing['objectName'] = input('Enter Target name: ')

        # Try coord lookup
        try:
            coord = SkyCoord.from_name(mpointing['objectName'])
        except Exception:
            coord = None
        if coord is not None:
            print('    Found catalogue object: ra={:.4f}, dec={:.4f}'.format(coord.ra.value,
                                                                             coord.dec.value))
            use_coords = None
            while use_coords not in ['y', 'n', 'Y', 'N']:
                use_coords = input('Use these coordinates? [y/n]: ')
            if use_coords in ['y', 'Y']:
                mpointing['ra'] = coord.ra.value
                mpointing['dec'] = coord.dec.value

        # Enter coords
        while mpointing['ra'] is None:
            ra_str = input('Target RA [h m s OR deg]: ')
            try:
                mpointing['ra'] = parse_ra(ra_str)
            except Exception:
                pass
        while mpointing['dec'] is None:
            dec_str = input('Target Dec [d m s OR deg]: ')
            try:
                mpointing['dec'] = parse_dec(dec_str)
            except Exception:
                pass

    # ToO & Rank
    too = None
    while too not in ['y', 'n', 'Y', 'N']:
        too = input('Is the target a ToO (can interupt)? [y/n]: ')
    if too in ['y', 'Y']:
        mpointing['ToO'] = 1
        print('    Setting ToO rank automatically to: high')
        mpointing['start_rank'] = 6
    else:
        mpointing['ToO'] = 0
        rank_str = 'None'
        while rank_str.lower() not in ['low', 'medium', 'high', 'l', 'm', 'h']:
            rank_str = input('Enter rank [low/medium/high]: ')

        if rank_str.lower() in ['low', 'l']:
            mpointing['start_rank'] = 8
        elif rank_str.lower() in ['medium', 'm']:
            mpointing['start_rank'] = 7
        elif rank_str.lower() in ['high', 'h']:
            mpointing['start_rank'] = 6

    # Valid time & wait time
    daily = None
    while daily not in ['y', 'n', 'Y', 'N']:
        daily = input('Use default cadance (once a night)? [y/n]: ')
    if daily in ['y', 'Y']:
        mpointing['valid_time'] = -1
        mpointing['wait_time'] = 1000  # ensures once a night
    else:
        while mpointing['valid_time'] is None:
            valid_time = input('Time for the pointing to be valid for (minutes, -1=infinite): ')
            try:
                mpointing['valid_time'] = int(valid_time)
            except Exception:
                pass

        while mpointing['wait_time'] is None:
            wait_time = input('Time between visits (minutes, can be array, 0=no wait): ')
            try:
                mpointing['wait_time'] = [int(i) for i in wait_time.split(',')]
            except Exception:
                pass

    # Number to do
    while mpointing['num_todo'] is None:
        num_todo = input('Number of visits? (-1=infinite): ')
        try:
            mpointing['num_todo'] = int(num_todo)
        except Exception:
            pass

    # Constraings
    default_cons = None
    while default_cons not in ['y', 'n', 'Y', 'N']:
        string = 'Use default constraints (alt>30, sunalt<-15, moon<B, moonsep>30)? [y/n]: '
        default_cons = input(string)
    if default_cons in ['y', 'Y']:
        mpointing['minAlt'] = 30
        mpointing['maxSunAlt'] = -15
        mpointing['maxMoon'] = 'B'
        mpointing['minMoonSep'] = 30
    else:
        while mpointing['minAlt'] is None:
            invalue = input('Minimum target altitude (degrees): ')
            try:
                mpointing['minAlt'] = float(invalue)
            except Exception:
                pass

        while mpointing['maxSunAlt'] is None:
            invalue = input('Maximum Sun altitude (degrees): ')
            try:
                mpointing['maxSunAlt'] = float(invalue)
            except Exception:
                pass

        while mpointing['maxMoon'] not in ['D', 'G', 'B']:
            invalue = input('Maximum Moon brightness [D/G/B]: ')
            try:
                mpointing['maxMoon'] = invalue.upper()
            except Exception:
                pass

        while mpointing['minMoonSep'] is None:
            invalue = input('Minimum seperation from the Moon (degrees): ')
            try:
                mpointing['minMoonSep'] = float(invalue)
            except Exception:
                pass

    return mpointing


def fill_exposure_set(exposure_set):
    """Fill out an exposure set frame with user input."""
    # Number of exposures
    while exposure_set['numexp'] is None:
        numexp = input('Number of exposures: ')
        try:
            exposure_set['numexp'] = int(numexp)
        except Exception:
            pass

    # Exposure time
    while exposure_set['expTime'] is None:
        exptime = input('Exposure time: ')
        try:
            exposure_set['expTime'] = int(exptime)
        except Exception:
            pass

    # Filter
    while exposure_set['filt'] not in ['L', 'R', 'G', 'B']:
        filt = input('Filter [L/R/G/B]: ')
        try:
            exposure_set['filt'] = filt.upper()
        except Exception:
            pass

    return exposure_set


if __name__ == '__main__':

    default_mpointing = {'user_id': None,
                         'objectName': None,
                         'ra': None,
                         'dec': None,
                         'ToO': None,
                         'start_rank': None,
                         'num_todo': None,
                         'valid_time': None,
                         'wait_time': None,
                         'minAlt': None,
                         'maxSunAlt': None,
                         'maxMoon': None,
                         'minMoonSep': None,
                         # auto filled values
                         'minTime': None,
                         }

    exposure_sets = []

    default_exposure_set = {'numexp': None,
                            'expTime': None,
                            'filt': None,
                            # default values:
                            'binning': 1,
                            'typeFlag': 'SCIENCE',
                            'raoff': 0,
                            'decoff': 0,
                            'utMask': None,
                            }

    with db.open_session() as session:
        print("** Insert pointing into GOTO queue database **")

        # Get user_id
        # username = input('Enter your database username: ')
        # if username is None:
        #     username = 'goto'
        print('Using default username: goto')
        username = 'goto'

        # Fill Mpointing infomation
        mpointing = default_mpointing.copy()
        mpointing['user_id'] = get_user_id(session, username)
        mpointing = fill_mpointing(mpointing)

        # Fill Exposure Set infomation
        exposure_sets = []

        total_exptime = 0
        more_exposures = True
        while more_exposures is True:
            exposure_set = fill_exposure_set(default_exposure_set.copy())

            total_exptime += (exposure_set['expTime'] + 30) * exposure_set['numexp']
            exposure_sets.append(exposure_set)

            add_more = None
            while add_more not in ['y', 'Y', 'n', 'N']:
                add_more = input('Add another exposure set? [y/n]: ')

            if add_more not in ['y', 'Y']:
                more_exposures = False

        mpointing['minTime'] = total_exptime

        mp = db.Mpointing(**mpointing)
        for exposure_set in exposure_sets:
            es = db.ExposureSet(**exposure_set)
            mp.exposure_sets.append(es)

        print('~~ Final check ~~')
        print(mp)
        for es in mp.exposure_sets:
            print(es)

        confirm = None
        while confirm not in ['y', 'Y', 'n', 'N']:
            confirm = input('Add to the database? [y/n]: ')

        if confirm in ['y', 'Y']:
            db.insert_items(session, [mp])
            print('Inserted into observation database')
