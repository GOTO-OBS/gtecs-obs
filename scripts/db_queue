#!/usr/bin/env python3
"""A script to view the current pointing queue."""

import argparse

from astroplan import Observer

from astropy import units as u
from astropy.time import Time

from gtecs.common.style import boldtxt, gtxt, rtxt, ytxt
from gtecs.obs import database as db
from gtecs.obs.scheduler import PointingQueue

import numpy as np


def run(telescope_id, time, horizon, readout_time, limit=None):
    """Print the current queue."""
    print(boldtxt('Pointings queue for Telescope {}'.format(telescope_id)), end='')
    print(boldtxt(' at {} UTC'.format(time.iso)), end='')
    print(': ')

    # Create Queue from DB
    queue = PointingQueue.from_database(telescope_id, time)
    if len(queue) == 0:
        print('No pointings in queue')
        return

    # Calculate pointing validity at the given time
    queue.calculate(horizon, readout_time)

    # Get the pointings, now with extra infomation
    pointing_list = list(queue.pointings)
    pointing_list.sort(key=lambda p: (not p.valid, p.rank, not p.too, p.num_obs, p.tiebreaker))
    n_pointings = len(pointing_list)
    n_valid = len([p for p in pointing_list if p.valid])
    print('{} pointings, {} valid'.format(n_pointings, n_valid))

    # Limit to the given limit
    pointing_list = pointing_list[:limit]

    # Get the max name length, for nicer formatting
    name_len = int(max(len(p.name) for p in pointing_list)) + 2

    # Print the pointings
    all_cons = {}
    print('  db_id | {: >{w}} | Vld | Rnk | ToO | Nobs | TieBrk | Constraints'.format(
          'Object name', w=name_len))
    for pointing in pointing_list[:limit]:

        if pointing.current:
            print(ytxt('{: >7.0f}'.format(pointing.db_id)), end=' | ')
            print(ytxt('{: >{w}}'.format(pointing.name, w=name_len)), end=' | ')
        else:
            print('{: >7.0f}'.format(pointing.db_id), end=' | ')
            print('{: >{w}}'.format(pointing.name, w=name_len), end=' | ')

        print(gtxt(' Y ') if pointing.valid else rtxt(' N '), end=' | ')

        print('{: >3.0f}'.format(pointing.rank) if pointing.rank != np.inf else 'inf', end=' | ')
        print(' Y ' if pointing.too else ' N ', end=' | ')
        print('{: >4.0f}'.format(pointing.num_obs), end=' | ')
        print('{: >6.4f}'.format(pointing.tiebreaker), end=' | ')

        cons = [(name, valid) for name, valid in zip(pointing.constraint_names, pointing.valid_arr)]
        cons.sort(key=lambda i: i[0])

        for name, valid in cons:
            short_name = ''.join(c for c in name if not c.islower())
            if len(short_name) == 1:
                short_name = ''.join([c for c in name if c not in ('a', 'e', 'i', 'o', 'u')])[:3]
            if valid:
                print(gtxt(short_name), end=' ')
            else:
                print(rtxt(short_name), end=' ')
            if name not in all_cons:
                all_cons[name] = short_name

        print(end='\n')
    if limit != -1 and n_pointings > limit:
        print(' ...and {} more'.format(n_pointings - limit))

    print('Constraints: ', end='')
    for name in sorted(all_cons):
        if '_' not in name:
            print('{}={}'.format(boldtxt(all_cons[name]), name), end='  ')
    print('{}=end'.format(boldtxt('_')))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    time_group = parser.add_mutually_exclusive_group()
    time_group.add_argument('-T', '--telescope', default=None,
                            help='ID number for the telescope to get the queue for (default=all)')
    time_group.add_argument('-t', '--time', default=None,
                            help='Time to check the queue at (default=Now)')
    time_group.add_argument('-s', '--sunalt', default=None,
                            help='Sun altitude to check the queue at (next)')
    parser.add_argument('-l', '--horizon-limit', type=int, default=30,
                        help='Telescope horizon limit (default=30 degrees)')
    parser.add_argument('-r', '--readout-time', type=int, default=10,
                        help='The expected time between each exposure (default=10 seconds)')
    lines_group = parser.add_mutually_exclusive_group()
    lines_group.add_argument('-n', '--lines', type=int,
                             help='Number of lines to print (default=20)')
    lines_group.add_argument('-a', '--all', action='store_true', default=False,
                             help='Print all items in the queue')
    args = parser.parse_args()

    if args.telescope is not None:
        telescopes = [int(args.telescope)]
    else:
        with db.open_session() as session:
            all_telescopes = session.query(db.Telescope).all()
            telescopes = [t.db_id for t in all_telescopes]

    if args.time is not None:
        time = Time(args.time)
    elif args.sunalt:
        sunalt = float(args.sunalt) * u.deg
        now = Time.now()
        if len(telescopes) > 1:
            raise ValueError('Cannot use --sunalt flag with multiple telescopes')
        with db.open_session() as session:
            t = db.get_telescope_by_id(telescopes[0])
            observer = Observer(t.site.location)
            if observer.sun_altaz(now).alt > sunalt:
                # Sun is above, get next time it sets below
                time = observer.sun_set_time(now, which='next', horizon=sunalt)
            else:
                # Sun is below, get next time it rises above
                time = observer.sun_rise_time(now, which='next', horizon=sunalt)
    else:
        time = Time.now()
    time.precision = 0

    min_alt = args.horizon_limit
    horizon = ([0, 90, 180, 270, 360], [min_alt, min_alt, min_alt, min_alt, min_alt])
    readout_time = args.readout_time

    if args.all:
        limit = -1
    elif args.lines:
        limit = args.lines
    else:
        limit = int(20 / len(telescopes))

    for telescope_id in telescopes:
        run(telescope_id, time, horizon, readout_time, limit)
