#!/usr/bin/env python3
"""A script to view the current pointing queue."""

import argparse

from astroplan import Observer

from astropy import units as u
from astropy.coordinates import EarthLocation
from astropy.time import Time

from gtecs.common.style import boldtxt, gtxt, rtxt, ytxt
from gtecs.obs.scheduler import PointingQueue


def run(time, observer, horizon, limit=None):
    """Print the current queue."""
    # Create Queue from DB
    queue = PointingQueue.from_database(time, observer)
    if len(queue) == 0:
        print('No pointings in queue')
        return

    #  Apply constraints and calculate tiebreakers for all pointings
    queue.apply_constraints(time, observer, horizon)
    queue.calculate_tiebreakers(time, observer)

    # Get the pointings, now with extra infomation
    pointing_list = list(queue.pointings)
    pointing_list.sort(key=lambda p: (not p.valid, p.rank, not p.too, p.num_obs, p.tiebreaker))
    n_pointings = len(pointing_list)
    n_valid = len([p for p in pointing_list if p.valid])
    pointing_list = pointing_list[:limit]

    # Get the max name length, for nicer formatting
    name_len = int(max(len(p.name) for p in pointing_list)) + 2

    # Print the pointings
    all_cons = {}
    print(boldtxt('Pointings queue at {} UTC'.format(time.iso)), end='')
    print(': {} pointings, {} valid'.format(n_pointings, n_valid))
    print('  db_id | {: >{w}} | Vld | Rnk | ToO | Nobs | TieBrk | Constraints'.format(
          'Object name', w=name_len))
    for pointing in pointing_list[:limit]:

        if pointing.current:
            print(ytxt('{: >7.0f}'.format(pointing.db_id)), end=' | ')
            print(ytxt('{: >{w}}'.format(pointing.name, w=name_len)), end=' | ')
        else:
            print('{: >7.0f}'.format(pointing.db_id), end=' | ')
            print('{: >{w}}'.format(pointing.name, w=name_len), end=' | ')

        print(gtxt(' Y ') if pointing.valid else rtxt(' N '), end=' | ')

        print('{: >3.0f}'.format(pointing.rank), end=' | ')
        print(' Y ' if pointing.too else ' N ', end=' | ')
        print('{: >4.0f}'.format(pointing.num_obs), end=' | ')
        print('{: >6.4f}'.format(pointing.tiebreaker), end=' | ')

        cons = [(name, valid) for name, valid in zip(pointing.constraint_names, pointing.valid_arr)]
        cons.sort(key=lambda i: i[0])

        for name, valid in cons:
            short_name = ''.join(c for c in name if not c.islower())
            if valid:
                print(gtxt(short_name), end=' ')
            else:
                print(rtxt(short_name), end=' ')
            if name not in all_cons:
                all_cons[name] = short_name

        print(end='\n')
    if limit != -1 and n_pointings > limit:
        print(' ...and {} more'.format(n_pointings - limit))

    print('Constraints: ', end='')
    for name in sorted(all_cons):
        if '_' not in name:
            print('{}={}'.format(boldtxt(all_cons[name]), name), end='  ')
    print('{}=mintime'.format(boldtxt('_')))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    time_group = parser.add_mutually_exclusive_group()
    time_group.add_argument('-t', '--time',
                            help='Time to check the queue at (default=Now)')
    time_group.add_argument('-s', '--sunalt', default=None,
                            help='Sun altitude to check the queue at (next)')
    parser.add_argument('-S', '--site', type=str, default='lapalma',
                        help='Site to observe from (default="LaPalma")')
    parser.add_argument('-l', '--horizon-limit', type=int, default=30,
                        help='Telescope horizon limit (default=30 degrees)')
    lines_group = parser.add_mutually_exclusive_group()
    lines_group.add_argument('-n', '--lines', type=int, default=20,
                             help='Number of lines to print (default=20)')
    lines_group.add_argument('-a', '--all', action='store_true', default=False,
                             help='Print all items in the queue')
    args = parser.parse_args()

    location = EarthLocation.of_site(args.site)
    observer = Observer(location)

    if args.time:
        time = Time(args.time)
    elif args.sunalt:
        sunalt = float(args.sunalt) * u.deg
        time = Time.now()
        if observer.sun_altaz(time).alt > sunalt:
            # Sun is above, get next time it sets below
            time = observer.sun_set_time(time, which='next', horizon=sunalt)
        else:
            # Sun is below, get next time it rises above
            time = observer.sun_rise_time(time, which='next', horizon=sunalt)
    else:
        time = Time.now()
    time.precision = 0

    min_alt = args.horizon_limit
    horizon = ([0, 90, 180, 270, 360], [min_alt, min_alt, min_alt, min_alt, min_alt])

    if args.all:
        limit = -1
    elif args.lines:
        limit = args.lines
    else:
        limit = 20

    run(time, observer, horizon, limit)
