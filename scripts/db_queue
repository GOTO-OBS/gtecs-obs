#!/usr/bin/env python3
"""A script to view the current pointing queue."""

import argparse

from astroplan import Observer

from astropy import units as u
from astropy.time import Time

from gtecs import astronomy
from gtecs.scheduler import PointingQueue
from gtecs.style import boldtxt, gtxt, rtxt, ytxt


def run(time, limit):
    """Print the current queue."""
    time.precision = 0
    observer = Observer(astronomy.observatory_location())

    # Create Queue from DB
    queue = PointingQueue.from_database(time, observer)
    if len(queue) == 0:
        print('No pointings in queue')
        return

    #  Apply constraints and calculate tiebreakers for all pointings
    queue.apply_constraints(time, observer)
    queue.calculate_tiebreakers(time, observer)

    # Get the pointings, now with extra infomation
    pointing_list = list(queue.pointings)
    pointing_list.sort(key=lambda p: (not p.valid, p.rank, not p.too, p.num_obs, p.tiebreaker))
    pointing_list = pointing_list[:limit]

    # Get the max name length, for nicer formatting
    name_len = int(max(len(p.name) for p in pointing_list)) + 2

    # Print the pointings
    all_cons = {}
    print('Pointings queue at {} UTC:'.format(time.iso))
    print(' db_id | {: >{w}} | Vld | Rnk | ToO | Nobs | TieBrk | Constraints'.format(
          'Object name', w=name_len))
    reached_invalid = False
    for pointing in pointing_list[:limit]:
        if not pointing.valid and not reached_invalid:
            print('----------------')
            reached_invalid = True

        print('{: >6.0f}'.format(pointing.db_id), end=' | ')

        if pointing.current:
            print(ytxt('{: >{w}}'.format('*' + pointing.name + '*', w=name_len)), end=' | ')
        else:
            print('{: >{w}}'.format(pointing.name, w=name_len), end=' | ')

        print(gtxt(' Y ') if pointing.valid else rtxt(' N '), end=' | ')

        print('{: >3.0f}'.format(pointing.rank), end=' | ')
        print(' Y ' if pointing.too else ' N ', end=' | ')
        print('{: >4.0f}'.format(pointing.num_obs), end=' | ')
        print('{: >6.4f}'.format(pointing.tiebreaker), end=' | ')

        cons = [(name, valid) for name, valid in zip(pointing.constraint_names, pointing.valid_arr)]
        cons.sort(key=lambda i: i[0])

        for name, valid in cons:
            short_name = ''.join(c for c in name if not c.islower())
            if valid:
                print(gtxt(short_name), end=' ')
            else:
                print(rtxt(short_name), end=' ')
            if name not in all_cons:
                all_cons[name] = short_name

        print(end='\n')
    if limit != -1 and len(pointing_list) > limit:
        print(' ...and {} more'.format(len(pointing_list) - limit))

    print('Constraints: ', end='')
    for name in sorted(all_cons):
        if '_' not in name:
            print('{}={}'.format(boldtxt(all_cons[name]), name), end='  ')
    print('{}=mintime'.format(boldtxt('_')))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--time', nargs='?', default=None,
                        help='Time to check the queue at')
    parser.add_argument('-s', '--sunalt', nargs='?', default=None,
                        help='Sun altitude to check the queue at (next)')
    parser.add_argument('-n', '--lines', nargs='?', type=int, default=20,
                        help='Number of lines to print')
    parser.add_argument('-a', '--all', action='store_true', default=False)
    args = parser.parse_args()

    if args.time:
        time = Time(args.time)
    elif args.sunalt:
        sunalt = float(args.sunalt) * u.deg
        today = astronomy.night_startdate()
        time = astronomy.sunalt_time(today, sunalt,
                                     Time.now() < astronomy.local_midnight(today))
    else:
        time = Time.now()

    if args.all:
        limit = -1
    elif args.lines:
        limit = args.lines
    else:
        limit = 20

    run(time, limit)
