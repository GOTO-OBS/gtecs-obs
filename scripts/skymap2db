#!/usr/bin/env python
"""A script to approximate what the GOTO sentinel should be doing.

- Read in a LIGO GW skymap
- Split it up into tiles
- Insert those tiles into the GOTO database
"""

import argparse
import os
import time

import astropy.units as u
from astropy.time import Time

from gototile.grid import SkyGrid
from gototile.skymap import SkyMap

import obsdb as db


DB_USER = 'goto'
DB_PW = 'G0T0'
DB_NAME = 'GOTO GW alerts'

# Constant Pointing values
MPOINTING_SETTINGS = dict(start_rank=2,
                          min_alt=30,
                          min_time=(60 + 30) * 3,
                          max_sunalt=-18,
                          max_moon='B',
                          min_moonsep=30,
                          too=0,
                          num_todo=5,
                          valid_time=1440,
                          wait_time=0)

# Constant ExposureSet values
EXP_SETTINGS = dict(num_exp=3,
                    exptime=60,
                    filt='L',
                    binning=1,
                    imgtype='SCIENCE')


def add_to_database(db_grid, pointings, event_time, event_name, filename):
    """Add an event and its tiles to the GOTO database."""
    with db.open_session() as session:
        # Connect to the user, or create it if it doesn't exist
        try:
            user_id = db.get_user_id(session, DB_USER)
        except Exception:
            db.add_user(session, DB_USER, DB_PW, DB_NAME)
            user_id = db.get_user_id(session, DB_USER)

        # Create Event
        event = db.Event(name=event_name,
                         ivorn=str(event_time),  # no official IVORN yet
                         source='LVC',
                         event_type='GW',
                         time=Time.now(),
                         skymap=filename)
        session.add(event)

        # Create Survey
        survey = db.Survey(name=event_name)
        survey.grid = db_grid
        survey.event = event
        session.add(survey)

        # Go through the pointings to create survey tiles
        for pointing in pointings:
            # Get pointing infomation
            tilename = str(pointing['tilename'])
            prob = float(pointing['prob'])

            # Find the matched Grid tile
            grid_tile = db.get_grid_tile_by_name(session, db_grid.name, tilename)

            # Create an SurveyTile and add to the database
            survey_tile = db.SurveyTile(weight=prob)
            survey_tile.survey = survey
            survey_tile.grid_tile = grid_tile
            session.add(survey_tile)

            # Create Mpointing and add to the database
            object_name = '{}_{}'.format(event_name, tilename)

            mpointing = db.Mpointing(user_id=user_id,
                                     object_name=object_name,
                                     **MPOINTING_SETTINGS)
            mpointing.exposure_sets.append(db.ExposureSet(**EXP_SETTINGS))

            mpointing.grid_tile = grid_tile
            mpointing.survey_tile = survey_tile
            mpointing.event = event

            session.add(mpointing)


def run(filename, hp_lim=0.001, n_lim=20):
    """Create the mpointings and add them to the database."""
    with db.open_session() as session:
        # Find the current Grid in the database
        db_grids = session.query(db.Grid).all()
        if not db_grids:
            raise ValueError('No defined grids found!')
        else:
            # Might have multiple grids defined, just take the latest...
            db_grid = db_grids[-1]

        # Create a SkyGrid from the database Grid
        fov = {'ra': db_grid.ra_fov * u.deg, 'dec': db_grid.dec_fov * u.deg}
        overlap = {'ra': db_grid.ra_overlap, 'dec': db_grid.dec_overlap}
        grid = SkyGrid(fov, overlap, kind=db_grid.algorithm)

    # open skymap and get event details
    print('Loading skymap...')
    skymap = SkyMap.from_fits(filename)
    event_time = skymap.date_det
    event_name = skymap.objid
    print('  loaded event {}'.format(event_name))

    # apply the skymap to the grid
    print('Getting skymap tile pointings')
    grid.apply_skymap(skymap)
    pointings = grid.get_table()
    pointings.sort('prob')
    pointings.reverse()
    print('  loaded {} pointings'.format(len(pointings)))

    # filter out low-priority pointings
    print('Filtering to tiles that contain more than {}%'.format(hp_lim * 100))
    hp_mask = pointings['prob'] > hp_lim
    selected_pointings = pointings[hp_mask]
    print('  found {} tiles that cover {:.1f}% of the skymap'.format(
        len(selected_pointings),
        sum(selected_pointings['prob']) / sum(pointings['prob']) * 100))

    # make sure we always add a minimum number of tiles
    if len(selected_pointings) < n_lim:
        print('Adding {} extra tiles to reach a minimum of {}'.format(
            n_lim - len(selected_pointings), n_lim))
        selected_pointings = pointings[:n_lim]
        print('  found {} tiles that cover {:.1f}% of the skymap'.format(
            len(selected_pointings),
            sum(selected_pointings['prob']) / sum(pointings['prob']) * 100))

    # add pointings to the database
    print('Adding {} tiles to the database...'.format(len(selected_pointings)))
    start = time.time()
    add_to_database(db_grid, selected_pointings, event_time, event_name, filename)
    print('  took {:.2f} secs'.format(time.time() - start))


if __name__ == '__main__':
    description = """Convert a GOTO-tile output file containing a list of tiles
                     and priorities into observation files for the G-TeCS
                     observation queue."""

    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('filename', help="skymap file")
    parser.add_argument('--priority', help="minimum priority", type=float, default=0.001)
    parser.add_argument('--number', help="minimum number", type=int, default=20)

    args = parser.parse_args()

    filename = os.path.realpath(args.filename)  # unpack relative paths

    run(filename, hp_lim=args.priority, n_lim=args.number)
